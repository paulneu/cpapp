"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("./types");
const annotation_converter_1 = require("@sap-ux/annotation-converter");
const edmx_parser_1 = require("@sap-ux/edmx-parser");
const common_1 = require("../../specification/common");
const schemaAccess_1 = require("../../specification/schemaAccess");
const i18next_1 = __importDefault(require("i18next"));
const v2_1 = require("../../specification/v2");
const v4_1 = require("../../specification/v4");
const extensionLogger_1 = require("../../extensionLogger");
const deepmerge_1 = __importDefault(require("deepmerge"));
var TemplateType;
(function (TemplateType) {
    TemplateType["ListReportObjectPageV2"] = "ListReportObjectPageV2";
    TemplateType["ListReportObjectPageV4"] = "ListReportObjectPageV4";
    TemplateType["OverviewPageV2"] = "OverviewPageV2";
    TemplateType["AnalyticalListPageV2"] = "AnalyticalListPageV2";
    TemplateType["AnalyticalListPageV4"] = "AnalyticalListPageV4";
})(TemplateType = exports.TemplateType || (exports.TemplateType = {}));
exports.DEFINITION_LINK_PREFIX = '#/definitions/';
/**
 * Function returns annotation path for schema based on received params.
 * @param entityTypeName - Entity type name.
 * @param term - Annotation term.
 * @param qualifier - Annotation qualifier.
 * @returns Annotation path based on received params
 */
exports.createAnnotationPath = (entityTypeName, term, qualifier) => {
    let annotationPath = `/${entityTypeName}/@${term}`;
    if (qualifier) {
        annotationPath += `#${qualifier}`;
    }
    return annotationPath;
};
/**
 * Parses, merges, and converts a list of annotation files with aid of tools from annotation-vocabularies-tools
 * @param annotationFiles - The list of all annotation files, in JSON format
 * @returns the complete service information
 */
function parseAndMergeAndConvert(annotationFiles, logger) {
    const parseResult = [];
    try {
        if (annotationFiles) {
            annotationFiles.forEach(function (annotationData) {
                parseResult.push(edmx_parser_1.parseEDMX(annotationData.fileContent, annotationData.dataSourceUri));
            });
        }
        const converterOutput = annotation_converter_1.convertTypes(edmx_parser_1.merge(parseResult));
        if (logger && converterOutput.diagnostics) {
            for (let index = 0; index < converterOutput.diagnostics.length; index++) {
                const converterMessage = converterOutput.diagnostics[index];
                extensionLogger_1.log(logger, {
                    severity: "error" /* Error */,
                    message: converterMessage.message
                });
            }
        }
        return converterOutput;
    }
    catch (error) {
        extensionLogger_1.log(logger, {
            severity: "error" /* Error */,
            message: i18next_1.default.t('ANNOERR')
        }, ...error);
    }
}
exports.parseAndMergeAndConvert = parseAndMergeAndConvert;
exports.getAnnotationPropertyValue = (annotationProperty) => (annotationProperty === null || annotationProperty === void 0 ? void 0 : annotationProperty.value) || (annotationProperty === null || annotationProperty === void 0 ? void 0 : annotationProperty.path);
/**
 * Checks for Common.Label and overwrites the label from it if present
 * @param {PropertyAnnotations} annotations - property annotations
 * @param {EntityType} entityType - entity type
 * @param {string} label - label, to be actualized
 */
function evaluateCommonLabel(annotations, entityType, label) {
    var _a, _b, _c, _d;
    if ((_a = annotations === null || annotations === void 0 ? void 0 : annotations.Common) === null || _a === void 0 ? void 0 : _a.Label) {
        if (typeof annotations.Common.Label === 'string') {
            label = annotations.Common.Label;
        }
        else if (annotations.Common.Label['type'] === 'Path') {
            const targetProperty = entityType.resolvePath(annotations.Common.Label['path']);
            label = targetProperty.value
                ? targetProperty.value
                : typeof ((_b = targetProperty.Common) === null || _b === void 0 ? void 0 : _b.Label) === 'string'
                    ? targetProperty.annotations.Common.Label
                    : label;
        }
        else if (typeof ((_d = (_c = annotations.Common) === null || _c === void 0 ? void 0 : _c.Label) === null || _d === void 0 ? void 0 : _d.toString()) === 'string') {
            label = annotations.Common.Label.toString();
        }
    }
    return label;
}
exports.evaluateCommonLabel = evaluateCommonLabel;
/**
 * Determines the label for a property path
 * @param {PropertyPath} propertyPath - property path
 * @param {EntityType} entityType - entity type
 * @returns label, derived from Common.Label or from property value
 */
function getLabelForPropertyPath(propertyPath, entityType) {
    let label = propertyPath.value;
    label = evaluateCommonLabel(propertyPath.$target.annotations, entityType, label);
    return label;
}
exports.getLabelForPropertyPath = getLabelForPropertyPath;
/**
 * Determines the label for a LineItem record
 * @param {DataFieldAbstractType} field - Line item record
 * @param {EntityType} entityType - entity type
 * @returns label, derived from Common.Label or from property value
 */
function getLabelForDataField(field, entityType) {
    var _a, _b;
    let label, property;
    if (field['Value']) {
        if (typeof field['Value'] === 'string') {
            property = entityType.entityProperties.find((ep) => ep.name === field['Value']);
        }
        else {
            property = entityType.resolvePath(field['Value'].path);
            if (!property) {
                property = field['Value'].$target;
            }
        }
    }
    else if (field['Target'] && field['Target'].$target && field['Target'].$target.Value) {
        property = field['Target'].$target.Value.$target;
    }
    if ((_b = (_a = property === null || property === void 0 ? void 0 : property.annotations) === null || _a === void 0 ? void 0 : _a.Common) === null || _b === void 0 ? void 0 : _b.Label) {
        label = evaluateCommonLabel(property.annotations, entityType, label);
    }
    return label;
}
exports.getLabelForDataField = getLabelForDataField;
/**
 * Function to resolve the dataField label
 * @param dataFieldLabel - Given dataField label; might be of type string, or an object in case of a path reference
 * @param entityType - the entity type as part of the AVT ConverterOutput
 * @returns undefined or the right string value
 */
function getLabel(dataFieldLabel, entityType) {
    var _a, _b;
    if (typeof dataFieldLabel === 'string') {
        return dataFieldLabel;
    }
    else if (typeof dataFieldLabel === 'object' && dataFieldLabel.path) {
        const property = entityType.resolvePath(dataFieldLabel.path);
        if (!property || property.length === 0) {
            return undefined;
        }
        else {
            const singleProperty = property[0];
            if ((_b = (_a = singleProperty === null || singleProperty === void 0 ? void 0 : singleProperty.annotations) === null || _a === void 0 ? void 0 : _a.Common) === null || _b === void 0 ? void 0 : _b.Label) {
                const label = dataFieldLabel;
                return evaluateCommonLabel(singleProperty.annotations, entityType, label);
            }
        }
    }
    else {
        return undefined;
    }
}
function getTitleForDataField(dataField, entityType, dataFieldLabel) {
    const propertyCommonLabel = getLabelForDataField(dataField, entityType);
    const title = dataFieldLabel ||
        propertyCommonLabel ||
        (dataField.Value.$target ? dataField.Value.$target.name : dataField.Value.value || dataField.Value.path);
    return { title, propertyCommonLabel };
}
/**
 * Determines the description of a data field, e.g. for the column header
 * @param dataFieldAbstract - the given record of the line item annotation
 * @param entityType - the entity type as part of the AVT ConverterOutput
 */
function getDatafieldDescription(dataFieldAbstract, entityType) {
    let title = '', propertyCommonLabel, dataField;
    const dataFieldLabel = getLabel(dataFieldAbstract.Label, entityType);
    switch (dataFieldAbstract.$Type) {
        case "com.sap.vocabularies.UI.v1.DataField" /* DataField */:
            dataField = dataFieldAbstract;
            ({ title, propertyCommonLabel } = getTitleForDataField(dataField, entityType, dataFieldLabel));
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldWithUrl" /* DataFieldWithUrl */:
            dataField = dataFieldAbstract;
            propertyCommonLabel = getLabelForDataField(dataFieldAbstract, entityType);
            title =
                dataFieldLabel ||
                    propertyCommonLabel ||
                    (typeof dataField.Value === 'string' ? dataField.Value : dataField.Value.path);
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldForAnnotation" /* DataFieldForAnnotation */:
            dataField = dataFieldAbstract;
            propertyCommonLabel = getLabelForDataField(dataFieldAbstract, entityType);
            title = dataFieldLabel || propertyCommonLabel || dataField.Target.$target.Title || dataField.Target.value;
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldForAction" /* DataFieldForAction */:
        case "com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation" /* DataFieldForIntentBasedNavigation */:
            dataField = dataFieldAbstract;
            if (dataFieldLabel) {
                title = typeof dataFieldLabel === 'string' ? dataFieldLabel : dataField.Action;
            }
            else {
                title = dataFieldAbstract.Action;
            }
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldWithIntentBasedNavigation" /* DataFieldWithIntentBasedNavigation */:
            dataField = dataFieldAbstract;
            propertyCommonLabel = getLabelForDataField(dataFieldAbstract, entityType);
            title = propertyCommonLabel || dataField.Value.path;
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldWithNavigationPath" /* DataFieldWithNavigationPath */:
            dataField = dataFieldAbstract;
            ({ title, propertyCommonLabel } = getTitleForDataField(dataField, entityType, dataFieldLabel));
            break;
        default:
            break;
    }
    return title;
}
exports.getDatafieldDescription = getDatafieldDescription;
/**
 * Return the page type for a given V2 page in manifest
 * @param name - page component name
 */
function getPageTypeV2(name) {
    if (name) {
        const templatePart = `${v2_1.FE_TEMPLATE_V2}.`;
        return name.split(templatePart)[1];
    }
}
exports.getPageTypeV2 = getPageTypeV2;
/**
 * Return the page type for a given V4 page in manifest
 * @param name - page component name
 */
function getPageTypeV4(name) {
    if (name) {
        const templatePart = `${v4_1.FE_TEMPLATE_V4}.`;
        return name.split(templatePart)[1];
    }
}
exports.getPageTypeV4 = getPageTypeV4;
function getTargetAnnotationName(targetAnnotation, keyForRelatedFacetKeys = false) {
    return `${!keyForRelatedFacetKeys ? '@' : ''}${targetAnnotation.qualifier ? targetAnnotation.term + '#' + targetAnnotation.qualifier : targetAnnotation.term}`;
}
/**
 * Finds the alias for a given namespace in the references' section of the converted service metadata
 * @param {string} namespace - complete namespace, e.g. 'com.sap.vocabularies.UI.v1'
 * @param {ConverterOutput} oDataServiceAVT - combined service metadata, as returned by annotation vocabularies tools
 * @returns alias for the given namespace
 */
function findAlias(namespace, oDataServiceAVT) {
    let aliasReference = oDataServiceAVT.references.find((reference) => {
        return reference.namespace === namespace;
    });
    if (!aliasReference) {
        aliasReference = oDataServiceAVT.references.find((reference) => {
            return reference.alias === namespace;
        });
    }
    if (!aliasReference) {
        aliasReference = oDataServiceAVT.references.find((reference) => {
            return (reference.alias.toUpperCase() ===
                namespace.split('SAP__')[namespace.split('SAP__').length - 1].toUpperCase());
        });
    }
    return aliasReference === null || aliasReference === void 0 ? void 0 : aliasReference.alias;
}
exports.findAlias = findAlias;
/**
 * Resolve page section(get key and label->description).
 * @param facetDefinition - the actual annotation record
 * @param keyForRelatedFacetKeys - construct key for 'keyForRelatedFacetKeys' property(used to define custom sections) - we should not add '@' symbol there.
 * @param {FioriElementsVersion} oDataVersion - OData version
 * @param {ConverterOutput} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @param {ExtensionLogger} logger - Logger class for logging messages
 * @returns {FacetSection} - object comprising the relevant facet information
 */
function getSectionFacet(facetDefinition, keyForRelatedFacetKeys = false, oDataVersion = common_1.FioriElementsVersion.v2, sourceEntityType, oDataServiceAVT, logger) {
    var _a;
    /**
     * Determines the target annotation
     * @param navigationParts - parts of the target annotation path
     * @param entityType - entity type
     * @returns the target annotation
     */
    function determineTargetAnnotation(navigationParts, entityType) {
        var _a;
        const lastNavigationPart = navigationParts[navigationParts.length - 1];
        const annotation = lastNavigationPart.substring(lastNavigationPart.lastIndexOf('.') + 1, lastNavigationPart.length);
        const alias = findAlias(lastNavigationPart.substring(0, lastNavigationPart.lastIndexOf('.')).replace('@', ''), oDataServiceAVT);
        const targetAnnotation = (_a = entityType === null || entityType === void 0 ? void 0 : entityType.annotations[alias]) === null || _a === void 0 ? void 0 : _a[annotation];
        return targetAnnotation;
    }
    /**
     * Adjust key by considering navigation
     * @param key - given key
     * @param navigationParts - parts of the target annotation path
     */
    function adjustKey(key, navigationParts) {
        const uiParts = (navigationParts[1] || navigationParts[0]).split('#');
        const uiClass = uiParts[0];
        if (uiClass.includes('.LineItem')) {
            const pathParts = key.split('::');
            pathParts[pathParts.length - 1] = `${!keyForRelatedFacetKeys ? '@' : ''}com.sap.vocabularies.UI.v1.LineItem`;
            key = pathParts.join('::');
        }
        else {
            key = uiClass.replace('@UI', `${!keyForRelatedFacetKeys ? '@' : ''}com.sap.vocabularies.UI.v1`);
        }
    }
    //---------Main-------------------------------------------------------------------------------------------
    //Take facet ID as fallback
    const facetName = facetDefinition.fullyQualifiedName.substr(facetDefinition.fullyQualifiedName.lastIndexOf('@'));
    let key = facetDefinition.ID ? facetDefinition.ID.toString() : facetName;
    let entityType = sourceEntityType; //default
    //If reference facet: overwrite with target annotation if present
    if (facetDefinition.$Type !== 'com.sap.vocabularies.UI.v1.CollectionFacet' && 'Target' in facetDefinition) {
        const propertyValue = exports.getAnnotationPropertyValue(facetDefinition.Target);
        if (!propertyValue) {
            extensionLogger_1.log(logger, {
                severity: "error" /* Error */,
                message: i18next_1.default.t('NOTARGET', { target: facetDefinition.Target })
            });
            return;
        }
        const navigationParts = propertyValue.split('/');
        const navigation = navigationParts.length > 1 ? navigationParts[0] : '';
        if (navigation) {
            entityType = (_a = sourceEntityType.resolvePath(navigation)) === null || _a === void 0 ? void 0 : _a.targetType;
        }
        adjustKey(key, navigationParts);
        const targetAnnotation = determineTargetAnnotation(navigationParts, entityType);
        if (targetAnnotation) {
            const separator = oDataVersion === common_1.FioriElementsVersion.v2 ? '::' : '#';
            key = getTargetAnnotationName(targetAnnotation, keyForRelatedFacetKeys).replace('#', separator);
        }
        else {
            return undefined;
        }
        if (navigation) {
            const navSeparator = oDataVersion === common_1.FioriElementsVersion.v2 ? '::' : '/';
            key = `${navigation}${navSeparator}${key}`;
        }
    }
    key = key.replace(/\//gi, '::');
    return key
        ? Object.assign(Object.assign(Object.assign({ key }, (facetDefinition.Label && { label: facetDefinition.Label.toString() })), (facetDefinition.ID && { ID: facetDefinition.ID.toString() })), { entityType }) : undefined;
}
exports.getSectionFacet = getSectionFacet;
/**
 * Finds the alias for a given namespace in the references' section of the converted service metadata
 * @param {object} exportResultManifest - manifest that is being modified during export
 * @param {string} path - path of the property in the manifest
 * @param {string} targetAnnotation
 * @param {string} targetAnnotationEncoded
 * @returns returns section of the manifest based on path, generates an empty object in case it does not exists
 */
exports.getManifestSectionByPathV4 = (exportResultManifest, path, targetAnnotation, targetAnnotationEncoded) => {
    let exportResultSection = exportResultManifest;
    path.split('/').forEach(function (element) {
        if (targetAnnotationEncoded && targetAnnotationEncoded === element) {
            element = targetAnnotation;
        }
        if (!exportResultSection[element]) {
            exportResultSection[element] = {};
        }
        exportResultSection = exportResultSection[element];
    });
    return exportResultSection;
};
function getSchemaKeyOfLineItemRecord(lineItemRecord) {
    let schemaKey, target, value;
    switch (lineItemRecord.$Type) {
        case "com.sap.vocabularies.UI.v1.DataField" /* DataField */:
            schemaKey = exports.getAnnotationPropertyValue(lineItemRecord.Value);
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldWithUrl" /* DataFieldWithUrl */:
            schemaKey =
                typeof lineItemRecord.Value === 'string'
                    ? lineItemRecord.Value
                    : exports.getAnnotationPropertyValue(lineItemRecord.Value);
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldForAnnotation" /* DataFieldForAnnotation */:
            target = lineItemRecord.Target.value;
            if (target) {
                schemaKey =
                    'DataFieldForAnnotation:::sTarget::' +
                        target
                            .replace('@UI', '@com.sap.vocabularies.UI.v1')
                            .replace('@Communication', '@com.sap.vocabularies.Communication.v1')
                            .replace('@Contact', '@com.sap.vocabularies.Contact.v1');
            }
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldForAction" /* DataFieldForAction */:
            if (lineItemRecord.Inline) {
                schemaKey = 'DataFieldForAction:::sAction::' + lineItemRecord.Action;
            }
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldWithIntentBasedNavigation" /* DataFieldWithIntentBasedNavigation */:
            value = exports.getAnnotationPropertyValue(lineItemRecord.Value);
            schemaKey =
                'DataFieldWithIntentBasedNavigation:::sProperty::' +
                    value +
                    ':::sSemanticObject::' +
                    lineItemRecord.SemanticObject +
                    ':::sAction::' +
                    lineItemRecord.Action;
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation" /* DataFieldForIntentBasedNavigation */:
            if (lineItemRecord.Inline) {
                schemaKey =
                    'DataFieldForIntentBasedNavigation:::sSemanticObject::' +
                        lineItemRecord.SemanticObject +
                        ':::sAction::' +
                        lineItemRecord.Action;
            }
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldWithNavigationPath" /* DataFieldWithNavigationPath */:
            value = exports.getAnnotationPropertyValue(lineItemRecord.Value);
            target = exports.getAnnotationPropertyValue(lineItemRecord.Target);
            schemaKey = 'DataFieldWithNavigationPath:::sProperty::' + value + ':::sTarget::' + target;
            break;
        default:
            break;
    }
    return schemaKey;
}
exports.getSchemaKeyOfLineItemRecord = getSchemaKeyOfLineItemRecord;
/**
 * Evaluates the target annotation of a reference facet and actualizes the facets for the config
 * @param {AnnotationTerm} annotationRecord - the actual annotation record
 * @param {FacetConfigs} facets - list of facets in config format, to be updated
 * @param {EntityType} entityType - the entity type
 * @param {ConverterOutput} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @param {FioriElementsVersion} oDataVersion - OData version
 * @param {ExtensionLogger} logger - Logger class for logging messages
 */
function evaluateTargetAnnotation(section, annotationRecord, facets, entityType, oDataServiceAVT, oDataVersion = common_1.FioriElementsVersion.v2, logger) {
    var _a, _b, _c, _d, _e;
    const alias = findAlias(types_1.UIVOCABULARY, oDataServiceAVT);
    let path = section ? section.key : '';
    const targetEntityType = section.entityType;
    let annotation, targetAnnotation;
    let scope = alias;
    if (path.includes('com.sap.vocabularies.UI.v1.Chart') || path.includes(alias + '.Chart')) {
        facets[path] = { base: types_1.FacetBase.Chart };
        facets[path]['entityType'] = targetEntityType;
    }
    else if (path.includes('com.sap.vocabularies.UI.v1.Identification') || path.includes(alias + '.Identification')) {
        annotation = path.split('.')[path.split('.').length - 1];
        targetAnnotation = targetEntityType.annotations[scope][annotation];
        facets[path] = { base: types_1.FacetBase.Identification };
        facets[path]['entityType'] = targetEntityType;
        facets[path]['target'] = targetAnnotation;
    }
    else if (entityType &&
        (path.includes('com.sap.vocabularies.UI.v1.LineItem') || path.includes(alias + '.LineItem'))) {
        if (path.includes('com.sap.vocabularies.UI.v1.LineItem')) {
            scope = path.split('com.sap.vocabularies.')[1].split('.')[0];
            annotation = path.split('com.sap.vocabularies.')[1].split('.')[2];
        }
        else if (path.includes('.LineItem')) {
            annotation = 'LineItem';
            const pathParts = path.split('::');
            pathParts[pathParts.length - 1] = '@com.sap.vocabularies.UI.v1.LineItem';
            path = pathParts.join('::');
        }
        facets[path] = { base: types_1.FacetBase.LineItem };
        facets[path]['lineItem'] = (_a = annotationRecord === null || annotationRecord === void 0 ? void 0 : annotationRecord.Target) === null || _a === void 0 ? void 0 : _a.$target;
        facets[path]['entityType'] = targetEntityType;
    }
    else if (path.includes('com.sap.vocabularies.UI.v1.FieldGroup') || path.includes(alias + '.FieldGroup')) {
        facets[path] = { base: types_1.FacetBase.Form };
        facets[path]['target'] = (_b = annotationRecord === null || annotationRecord === void 0 ? void 0 : annotationRecord.Target) === null || _b === void 0 ? void 0 : _b.$target;
        facets[path]['entityType'] = targetEntityType;
    }
    else if (path.includes('com.sap.vocabularies.UI.v1.DataPoint') || path.includes(alias + '.DataPoint')) {
        facets[path] = { base: types_1.FacetBase.DataPoint };
        facets[path].target = (_c = annotationRecord === null || annotationRecord === void 0 ? void 0 : annotationRecord.Target) === null || _c === void 0 ? void 0 : _c.$target;
        facets[path]['entityType'] = targetEntityType;
    }
    else if (path.includes('com.sap.vocabularies.Communication.v1.Contact') || path.includes(alias + '.Contact')) {
        facets[path] = { base: types_1.FacetBase.Contact };
        facets[path].target = (_d = annotationRecord === null || annotationRecord === void 0 ? void 0 : annotationRecord.Target) === null || _d === void 0 ? void 0 : _d.$target;
        facets[path]['entityType'] = targetEntityType;
    }
    else if (path.includes('com.sap.vocabularies.Communication.v1.Address') || path.includes(alias + '.Address')) {
        facets[path] = { base: types_1.FacetBase.Address };
        facets[path].target = (_e = annotationRecord === null || annotationRecord === void 0 ? void 0 : annotationRecord.Target) === null || _e === void 0 ? void 0 : _e.$target;
        facets[path]['entityType'] = targetEntityType;
    }
    else {
        facets[path] = { base: types_1.FacetBase.Unknown };
    }
    if (facets[path]) {
        facets[path].annotationPath = `/${annotationRecord.fullyQualifiedName.replace('@com.sap.vocabularies', types_1.VOCWITHSLASH)}`;
        if (annotationRecord.Label) {
            facets[path].Label = annotationRecord.Label;
        }
        // Add Facet ID
        if (annotationRecord.ID) {
            facets[path]['ID'] = annotationRecord.ID;
        }
        else if (oDataVersion === common_1.FioriElementsVersion.v4) {
            extensionLogger_1.log(logger, {
                severity: "error" /* Error */,
                message: i18next_1.default.t('NOID4SECTION', { facet: annotationRecord.fullyQualifiedName })
            });
        }
        if (section && section.entityType) {
            facets[path].entityType = section.entityType;
        }
    }
}
/**
 * Adds the information from facets to the config
 * @param {AnnotationTerm} annotationRecord - the actual annotation record
 * @param {ConverterOutput} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @param {string} serviceName - name of the service of the app
 * @param {string} entityName - the entity (type) name
 * @param {FacetConfigs} facets - list of facets in config format, to be updated
 * @param {FioriElementsVersion} oDataVersion - OData version
 * @param {ExtensionLogger} logger - Logger class for logging messages
 */
function addFacetToConfig(annotationRecord, oDataServiceAVT, serviceName, entityType, facets, oDataVersion = common_1.FioriElementsVersion.v2, logger) {
    var _a;
    const section = getSectionFacet(annotationRecord, false, oDataVersion, entityType, oDataServiceAVT, logger);
    if (section) {
        switch (annotationRecord.$Type) {
            case "com.sap.vocabularies.UI.v1.ReferenceFacet" /* ReferenceFacet */: {
                evaluateTargetAnnotation(section, annotationRecord, facets, entityType, oDataServiceAVT, oDataVersion, logger);
                break;
            }
            case "com.sap.vocabularies.UI.v1.CollectionFacet" /* CollectionFacet */: {
                const annotationPath = `/${entityType.fullyQualifiedName}/${annotationRecord.fullyQualifiedName.split(entityType.fullyQualifiedName)[1]}`;
                const facet = (facets[section.key] = {
                    base: types_1.FacetBase.CollectionFacet,
                    facets: {},
                    ID: section.ID,
                    annotationPath: annotationPath,
                    Label: section.label
                });
                (_a = annotationRecord.Facets) === null || _a === void 0 ? void 0 : _a.forEach((collectionItem) => {
                    addFacetToConfig(collectionItem, oDataServiceAVT, serviceName, entityType, facet.facets, oDataVersion, logger);
                });
                break;
            }
        }
    }
}
/**
 * Retrieve header facet configurations that can be used to generate ObjectPage schemas
 * @param {QualifiedName} entityTypeName - the name of the actual entity type
 * @param {ConverterOutput} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @param {FioriElementsVersion} oDataVersion - OData version
 * @param {ExtensionLogger} logger - Logger class for logging messages
 */
function getObjectPageHeaderFacets(entityType, oDataServiceAVT, oDataVersion = common_1.FioriElementsVersion.v2, logger) {
    const facets = {};
    if (!entityType || !entityType.annotations) {
        return;
    }
    const alias = findAlias(types_1.UIVOCABULARY, oDataServiceAVT);
    const facetAnnotation = alias && entityType.annotations[alias] && entityType.annotations[alias].HeaderFacets;
    if (facetAnnotation) {
        const lastDot = entityType.fullyQualifiedName.lastIndexOf('.');
        const serviceName = entityType.fullyQualifiedName.substr(0, lastDot);
        // Add facets to configuration
        facetAnnotation.forEach((item) => {
            addFacetToConfig(item, oDataServiceAVT, serviceName, entityType, facets, oDataVersion, logger);
        });
    }
    return facets;
}
exports.getObjectPageHeaderFacets = getObjectPageHeaderFacets;
/**
 * Retrieve facet configurations that can be used to generate ObjectPage schemas
 * @param {QualifiedName} entityTypeName - the name of the actual entity type
 * @param {ConverterOutput} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @param {FioriElementsVersion} oDataVersion - OData version
 * @param {ExtensionLogger} logger - Logger class for logging messages
 */
function getObjectPageFacets(entityType, oDataServiceAVT, oDataVersion = common_1.FioriElementsVersion.v2, logger) {
    const facets = {};
    if (!entityType || !entityType.annotations) {
        return;
    }
    const alias = findAlias(types_1.UIVOCABULARY, oDataServiceAVT);
    const facetAnnotation = alias && entityType.annotations[alias] && entityType.annotations[alias].Facets;
    if (facetAnnotation) {
        const lastDot = entityType.fullyQualifiedName.lastIndexOf('.');
        const serviceName = entityType.fullyQualifiedName.substr(0, lastDot);
        // Add facets to configuration
        facetAnnotation.forEach((item) => {
            addFacetToConfig(item, oDataServiceAVT, serviceName, entityType, facets, oDataVersion, logger);
        });
    }
    return facets;
}
exports.getObjectPageFacets = getObjectPageFacets;
/**
 * Returns the version of Fiori elements (v2/v4) from a given manifest
 * @param manifest - the manifest.json file
 */
function getVersionFromManifest(manifest) {
    if (manifest[v4_1.ManifestSection.generic] || manifest[v4_1.ManifestSection.ovp]) {
        return common_1.FioriElementsVersion.v2;
    }
    else {
        return common_1.FioriElementsVersion.v4;
    }
}
exports.getVersionFromManifest = getVersionFromManifest;
/**
 * Determines the template type of a V2 app
 * @param manifest - the manifest.json file
 * @param {ExtensionLogger} logger - Logger class for logging messages
 * @returns {TemplateType} the template type
 */
function determineV2Template(manifest, logger) {
    let templateType;
    if (manifest[v4_1.ManifestSection.generic]) {
        const v2Pages = manifest[v4_1.ManifestSection.generic].pages;
        if (!v2Pages) {
            extensionLogger_1.log(logger, {
                severity: "error" /* Error */,
                message: i18next_1.default.t('NOPAGES', { appId: manifest['sap.app']['id'] }),
                location: {
                    path: types_1.MANIFESTPATH,
                    range: [v4_1.ManifestSection.generic]
                }
            });
            return;
        }
        for (const pageKey in v2Pages) {
            const v2Page = v2Pages[pageKey];
            if (getPageTypeV2(v2Page.component.name) === common_1.PageType.AnalyticalListPage) {
                templateType = TemplateType.AnalyticalListPageV2;
                break;
            }
            else if (getPageTypeV2(v2Page.component.name) === common_1.PageType.ListReport) {
                templateType = TemplateType.ListReportObjectPageV2;
                break;
            }
        }
    }
    else {
        if (!templateType) {
            extensionLogger_1.log(logger, {
                severity: "error" /* Error */,
                message: i18next_1.default.t('NOTEMPLATE', { section: v4_1.ManifestSection.generic }),
                location: {
                    path: types_1.MANIFESTPATH,
                    range: [v4_1.ManifestSection.generic]
                }
            });
        }
    }
    return templateType;
}
exports.determineV2Template = determineV2Template;
/**
 * Determines the template type of a V4 app
 * @param manifest - the manifest.json file
 * @param {ExtensionLogger} logger - Logger class for logging messages
 * @returns {TemplateType} the template type
 */
function determineV4Template(manifest, logger) {
    let templateType;
    const v4Pages = manifest[v4_1.ManifestSection.ui5].routing &&
        manifest[v4_1.ManifestSection.ui5].routing.targets;
    if (!v4Pages) {
        extensionLogger_1.log(logger, {
            severity: "error" /* Error */,
            message: i18next_1.default.t('NOPAGES', { appId: manifest['sap.app']['id'] }),
            location: {
                path: types_1.MANIFESTPATH,
                range: [v4_1.ManifestSection.ui5, 'routing']
            }
        });
        return;
    }
    for (const pageKey in v4Pages) {
        const v4Page = v4Pages[pageKey];
        const pageType = getPageTypeV4(v4Page.name);
        if (pageType === common_1.PageTypeV4.AnalyticalListPage) {
            templateType = TemplateType.AnalyticalListPageV4;
            break;
        }
        else if (pageType === common_1.PageTypeV4.ListReport || pageType === common_1.PageTypeV4.ObjectPage) {
            templateType = TemplateType.ListReportObjectPageV4;
            break;
        }
    }
    if (!templateType) {
        extensionLogger_1.log(logger, {
            severity: "error" /* Error */,
            message: i18next_1.default.t('NOTEMPLATE', { section: v4_1.ManifestSection.ui5 }),
            location: {
                path: types_1.MANIFESTPATH,
                range: [v4_1.ManifestSection.ui5, 'routing', 'targets']
            }
        });
    }
    return templateType;
}
exports.determineV4Template = determineV4Template;
/**
 * Determines the template type, based on the given manifest entries of the app
 * @param manifest - the manifest.json file
 * @param {FioriElementsVersion} fioriElementsVersion - OData or FE version
 * @param {ExtensionLogger} logger - Logger class for logging messages
 * @returns {TemplateType} the template type
 */
function getTemplateTypeFromManifest(manifest, fioriElementsVersion, logger) {
    let templateType;
    if (manifest[v4_1.ManifestSection.ovp]) {
        templateType = TemplateType.OverviewPageV2;
    }
    else if (fioriElementsVersion === common_1.FioriElementsVersion.v2) {
        templateType = determineV2Template(manifest, logger);
    }
    else if (fioriElementsVersion === common_1.FioriElementsVersion.v4) {
        templateType = determineV4Template(manifest, logger);
    }
    else {
        if (!templateType) {
            extensionLogger_1.log(logger, {
                severity: "error" /* Error */,
                message: i18next_1.default.t('NOFE'),
                location: {
                    path: types_1.MANIFESTPATH
                }
            });
        }
    }
    return templateType;
}
exports.getTemplateTypeFromManifest = getTemplateTypeFromManifest;
/**
 * Adds title and description to a section or header section in an app schema
 * @param facet - intermediate facet structure comprising annotation information
 * @param section - section in the app schema
 * @param facetKey - key of the facet
 */
function addSectionTitleAndDescription(facet, section, facetKey) {
    if (facet === null || facet === void 0 ? void 0 : facet.ID) {
        section['title'] = types_1.FacetTitlePrefix + facet.ID;
    }
    else {
        section['title'] = facetKey.substr(facetKey.lastIndexOf('.') + 1);
    }
    // Description
    if (facet === null || facet === void 0 ? void 0 : facet.Label) {
        section['description'] = facet.Label;
    }
    else if (facet === null || facet === void 0 ? void 0 : facet.ID) {
        section['description'] = facet.ID;
    }
    else {
        section['description'] = facetKey.substr(facetKey.lastIndexOf('.') + 1);
    }
}
exports.addSectionTitleAndDescription = addSectionTitleAndDescription;
/**
 * Creates a default object for a new section or subsection, and adds the ID as title if present.
 * @param facet Facet configuration, to be analyzed
 * @returns the new section object
 */
function createSectionWithoutProperties(facet, facetKey) {
    if (!facet) {
        return undefined;
    }
    const section = {
        type: 'object',
        properties: {},
        additionalProperties: false,
        annotationPath: facet.annotationPath,
        isViewNode: true
    };
    addSectionTitleAndDescription(facet, section, facetKey);
    return section;
}
exports.createSectionWithoutProperties = createSectionWithoutProperties;
/**
 * Retrieve page section data(so far id/key and label/description).
 * @param {EntityType} entityType The actual entityType
 * @param {ConverterOutput} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @param {ExtensionLogger} logger - Logger class for logging messages
 * @param {FioriElementsVersion} oDataVersion - OData version
 * @param {boolean} [checkUnresolvableFacets=false] - Check and avoid facets and sections without ID and Target.
 * @returns {FacetSection[]} - Array of facets or sections
 */
function getObjectPageFacetSection(entityType, oDataServiceAVT, logger, oDataVersion = common_1.FioriElementsVersion.v2, checkUnresolvableFacets = false) {
    const alias = findAlias(types_1.UIVOCABULARY, oDataServiceAVT);
    let sections = [];
    if (entityType) {
        const facetAnnotation = alias && entityType.annotations && entityType.annotations[alias] && entityType.annotations[alias].Facets;
        if (facetAnnotation) {
            sections = facetAnnotation.reduce(function (result, item) {
                if (checkUnresolvableFacets && !item['ID'] && !('Target' in item && item['Target'])) {
                    return result;
                }
                const section = getSectionFacet(item, true, oDataVersion, entityType, oDataServiceAVT, logger);
                if (section) {
                    result.push(section);
                }
                return result;
            }, sections);
        }
        return sections;
    }
}
exports.getObjectPageFacetSection = getObjectPageFacetSection;
/**
 * Cleans empty sub-structures from the export result for manifest
 * @param manifest - manifest.json part of the export result
 * @param path  - path in the manifest
 * @param targetAnnotation - target annotation (optional, in case of sections, subsections)
 * @param targetAnnotationEncoded - encoded version of the target annotation, as represented in the manifest
 */
exports.deleteEmptyStructure = (manifest, path, targetAnnotation, targetAnnotationEncoded) => {
    let manifestSection = manifest;
    const pathArray = path.split('/');
    pathArray.forEach(function (element) {
        if (element === targetAnnotationEncoded) {
            element = targetAnnotation;
        }
        if (!manifestSection[element]) {
            return;
        }
        if (Object.keys(manifestSection[element]).length === 0) {
            delete manifestSection[element];
            pathArray.pop();
            exports.deleteEmptyStructure(manifest, pathArray.join('/'), targetAnnotation, targetAnnotationEncoded);
            return;
        }
        manifestSection = manifestSection && manifestSection[element];
    });
};
/**
 * Method which returns generic schema file name.
 * @param {SchemaType | PageType} schemaType Schema type or Page type.
 * @return {string} File name of generic schema.
 */
const getGenericSchemaFileName = (schemaType) => {
    return `${schemaType}`;
};
/**
 * Method which returns schema file name and path depending on passed schema or page type.
 * @param {SchemaType | PageType} schemaType Schema type or Page type.
 * @param {string} [entitySet] Entity set string.
 * @return {SchemaFilePath} File path info.
 */
exports.getSchemaFilePath = (schemaType, entitySet) => {
    const schemaFile = {
        filename: '',
        path: ''
    };
    switch (schemaType) {
        // Application schema
        case schemaAccess_1.SchemaType.Application: {
            // File name
            schemaFile.filename = `App`;
            // Full path
            schemaFile.path = `./${types_1.DirName.Schemas}/${schemaFile.filename}`;
            break;
        }
        // List report and object page
        case schemaAccess_1.SchemaType.ListReport:
        case schemaAccess_1.SchemaType.ObjectPage: {
            // File name
            schemaFile.filename = entitySet ? `${schemaType}_${entitySet}` : getGenericSchemaFileName(schemaType);
            // Full path
            schemaFile.path = `../${types_1.DirName.Schemas}/${schemaFile.filename}`;
            break;
        }
        // Other page configs
        default: {
            // File name
            schemaFile.filename = getGenericSchemaFileName(schemaType);
            // Full path
            schemaFile.path = `../${types_1.DirName.Schemas}/${schemaFile.filename}`;
            break;
        }
    }
    schemaFile.path += '.json';
    return schemaFile;
};
/**
 * Method which generates id of page according to passed parameters.
 * @param appVersion - Fiori Elements version - V2 or V4.
 * @param pageType - Page type.
 * @param entitySet - Entity Set.
 * @param navigationProperty - Navigation property (optional).
 * @param viewId - Custom page's viewId (optional).
 * @returns {string} Generated page id
 */
function generatePageId(pageType, entitySet, navigationProperty, viewId) {
    if (pageType === common_1.PageType.CustomPage) {
        const names = viewId && viewId.split('.');
        return names && names[names.length - 1] + 'Page';
    }
    const parts = [];
    parts.push(pageType);
    if (entitySet) {
        parts.push(entitySet);
    }
    // Page navigation - Optional
    if (navigationProperty) {
        parts.push(navigationProperty);
    }
    return parts.join('_');
}
exports.generatePageId = generatePageId;
/**
 * Fills an array of next definitions from given references in the JSON schema
 * @param propertyDefinition - Definition of the current property in schema
 * @param currentConfigObject - Current object in the config JSON. Evaluated to get the right value of a cntrolling property,
 *                              for making the right choice in case of multiple options (anyOf)
 * @param appSchema - app-spcific JSON schema
 * @returns an array of definitions to proceed with
 */
function fillArrayFromPropertyDefinition(propertyDefinition, currentConfigObject, appSchema) {
    const definitionArray = [];
    if (propertyDefinition['$ref']) {
        definitionArray.push(propertyDefinition['$ref'].split(exports.DEFINITION_LINK_PREFIX)[1]);
    }
    else if (propertyDefinition['anyOf']) {
        if (currentConfigObject) {
            propertyDefinition['anyOf'].forEach((element) => {
                if (element.$ref) {
                    const definitionKey = element.$ref.split(exports.DEFINITION_LINK_PREFIX)[1];
                    if (appSchema['definitions'][definitionKey]) {
                        const controlProperty = appSchema['definitions'][definitionKey]['controlProperty'];
                        if (element.$ref.includes(currentConfigObject[controlProperty])) {
                            definitionArray.push(definitionKey);
                        }
                    }
                }
            });
        }
        if (definitionArray.length === 0) {
            return undefined;
        }
    }
    return definitionArray;
}
/**
 * Determines the next definition to be handled, based on the definition array.
 * It also creates the Metadata instance for the next definition, to subsequently access metadata like the syncRule
 * @param definitionArray - Array of definitions, as determined by fillArrayFromNextDefinition
 * @param appSchema - app-spcific JSON schema
 * @param title - default title
 * @param currentConfigObject - Current object in the config JSON.
 * @param key - actual key
 * @param {MetadataInstanceInterface} factory - factory for creating metadata instances
 * @param pageType - page type
 * @param propertyDefinition - Definition of the current property in schema
 * @returns {NextDefinition} - Next target definition to process
 */
function determineNextDefinitionFromDefinitionArray(definitionArray, appSchema, title, currentConfigObject, key, factory, pageType, propertyDefinition) {
    let nextDefinition = {
        configObject: undefined,
        targetDefinition: {},
        title: ''
    };
    if (definitionArray.length) {
        const lastDefinition = definitionArray[definitionArray.length - 1];
        nextDefinition.targetDefinition = appSchema['definitions'][lastDefinition];
        if (nextDefinition.targetDefinition['$ref'] || nextDefinition.targetDefinition['type'] === 'array') {
            nextDefinition = getNextTargetDefinition(appSchema, title, currentConfigObject, nextDefinition.targetDefinition, key, factory, pageType);
            return nextDefinition;
        }
        if (definitionArray.length > 1) {
            definitionArray.forEach((element) => {
                if (element !== '') {
                    nextDefinition.targetDefinition['properties'] = Object.assign(Object.assign({}, nextDefinition.targetDefinition['properties']), appSchema['definitions'][element]['properties']);
                }
            });
        }
        nextDefinition.title =
            nextDefinition.targetDefinition && nextDefinition.targetDefinition['title']
                ? nextDefinition.targetDefinition['title']
                : title;
        const factoryKey = lastDefinition.split('<')[0];
        nextDefinition.configObject = factory.createInstance(pageType, factoryKey, currentConfigObject, nextDefinition.targetDefinition['controlProperty']);
    }
    else {
        //e.g. sections ==> loop over all properties = subsections or other
        nextDefinition.targetDefinition = propertyDefinition;
        nextDefinition.title = nextDefinition.targetDefinition['title']
            ? nextDefinition.targetDefinition['title']
            : key;
        nextDefinition.configObject = currentConfigObject;
    }
    return nextDefinition;
}
/**
 * Recursive function to determine the next config part, next definition in the app schema and the title
 * @param appSchema - app-spcific JSON schema
 * @param title - default title
 * @param currentConfigObject - current part of the configuration that gets traversed
 * @param propertyDefinition - definition of a given property in the app schema
 * @param key - actual key
 * @param {MetadataInstanceInterface} factory - factory for creating metadata instances
 * @param pageType - page type
 */
function getNextTargetDefinition(appSchema, title, currentConfigObject, propertyDefinition, key, factory, pageType) {
    let nextDefinition;
    if (propertyDefinition['type'] === 'array') {
        nextDefinition = getNextTargetDefinition(appSchema, title, currentConfigObject, propertyDefinition['items'], key, factory, pageType);
        return nextDefinition;
    }
    const definitionArray = fillArrayFromPropertyDefinition(propertyDefinition, currentConfigObject, appSchema);
    if (!definitionArray) {
        return undefined;
    }
    nextDefinition = determineNextDefinitionFromDefinitionArray(definitionArray, appSchema, title, currentConfigObject, key, factory, pageType, propertyDefinition);
    return nextDefinition;
}
exports.getNextTargetDefinition = getNextTargetDefinition;
/**
 * Add schema definitions for fields of createWithParameterDialog
 * @param {object} appSchema - Application-specific schema, to be enhanced
 * @param {EntityType} entityType - Given entity type for which entries shall get generated.
 */
function addFieldsType(appSchema, entityType) {
    const propertyNameArray = [], propertyObject = {};
    for (let key = 0; key < entityType.entityProperties.length; key++) {
        const propertyName = entityType.entityProperties[key].name;
        propertyNameArray.push(propertyName);
        propertyObject[propertyName] = {
            $ref: exports.DEFINITION_LINK_PREFIX + 'FieldPath'
        };
    }
    appSchema['definitions'][entityType.name] = {
        enum: propertyNameArray
    };
    appSchema['definitions']['FieldPath'].properties.path = {
        $ref: exports.DEFINITION_LINK_PREFIX + entityType.name
    };
    appSchema['definitions']['CreationFieldKeys'] = {
        type: 'object',
        properties: propertyObject,
        additionalProperties: false
    };
    const fields4Dialog = appSchema['definitions']['Fields4Dialog'] || appSchema['definitions']['Fields4DialogOP'];
    fields4Dialog.properties.fields = {
        $ref: exports.DEFINITION_LINK_PREFIX + 'CreationFieldKeys'
    };
}
exports.addFieldsType = addFieldsType;
/**
 * Functions used both by V2 and V4 to add the common definitions for a line item to the app schema
 * @param appSchema - the app specific schema that shall get enhanced
 * @param lineItemAnnotation - the UI.LineItem annotation, comprising all records
 * @param entityType - the entity type as part of the AVT ConverterOutput
 * @param lineItemId - line item ID, as comprise in stable ID
 * @returns the actions definition plus the annotation path to the given line item
 */
function addCommonLineItemDefinitions(appSchema, lineItemAnnotation, entityType, lineItemId) {
    let lineItemPath;
    appSchema['definitions'][lineItemId] = {
        type: 'object',
        properties: {},
        additionalProperties: false,
        isViewNode: true,
        description: 'Columns'
    };
    //Copy toolbar
    const toolBar = lineItemId === 'LineItems' ? 'ToolBar' : 'ObjectPageToolBar';
    const schemaIdForToolBar = `${toolBar}<${lineItemId}>`;
    appSchema['definitions'][schemaIdForToolBar] = JSON.parse(JSON.stringify(appSchema['definitions'][`${toolBar}`]));
    appSchema['definitions'][schemaIdForToolBar].properties.actions.$ref =
        exports.DEFINITION_LINK_PREFIX + 'Actions<' + lineItemId + '>';
    const schemaIdForActions = `Actions<${lineItemId}>`;
    const actionId = lineItemId === 'LineItems' ? 'Actions' : 'ObjectPageToolBarActions';
    const actions = (appSchema['definitions'][schemaIdForActions] = JSON.parse(JSON.stringify(appSchema['definitions'][actionId])));
    actions.properties = {};
    actions.additionalProperties = false;
    //Determine annotation path
    if (lineItemAnnotation) {
        lineItemPath = exports.createAnnotationPath(entityType.fullyQualifiedName, lineItemAnnotation.term, lineItemAnnotation.qualifier);
        appSchema['definitions'][lineItemId].annotationPath = appSchema['definitions'][schemaIdForToolBar].annotationPath = lineItemPath;
    }
    return { actions, lineItemPath };
}
exports.addCommonLineItemDefinitions = addCommonLineItemDefinitions;
/**
 * Method adds definition for 'RelatedFacetKeys' as enum with describtion and adds references to 'RelatedFacetKeys' for custom section definitions.
 * @param {object} schema App specific schema that potentially gets enhanced
 * @param {string[]>} sectionDefinitions array of section definitions which should be updated with new reference to 'RelatedFacetKeys' enum.
 * @param {FacetSection[]} facetSections Array of facet section objects which is used to generate enum values.
 * @param {Array<keyof Omit<FacetSection, 'custom'>>} idProperties Array of property names which should be looked up in 'FacetSection' object.
 *  Please note that method depends on order and takes first non empty value associated to passed properties.
 */
function addDefinitionForRelatedFacetKeys(schema, sectionDefinitions, facetSections, idProperties) {
    const oneOfSections = facetSections.map((section) => {
        // Loop accaptable properties in received order and find first entry with value
        const propertyName = idProperties.find((property) => !!section[property]);
        const schemaIdForSection = section[propertyName];
        return Object.assign(Object.assign({ const: schemaIdForSection }, (section.label && { description: section.label })), (section.custom && { custom: section.custom }));
    });
    // Change 'relatedFacet' only when we have entries for sections - otherwise use generic.
    if (oneOfSections.length) {
        // Create new definition in schema as 'oneOf'.
        // Simpler way would be to use 'enum', but then there no option to pass description.
        schema['definitions']['RelatedFacetKeys'] = {
            type: 'string',
            oneOf: oneOfSections
        };
        // Add enum definition
        for (const name of sectionDefinitions) {
            const definition = schema['definitions'][name];
            const property = definition['properties']['relatedFacet'];
            definition['properties']['relatedFacet'] = {
                anyOf: [
                    {
                        $ref: exports.DEFINITION_LINK_PREFIX + 'RelatedFacetKeys'
                    },
                    property
                ]
            };
        }
    }
}
exports.addDefinitionForRelatedFacetKeys = addDefinitionForRelatedFacetKeys;
/**
 * Custom array merge function called by deepmerge's merge function
 *
 * @param {*} target Target array
 * @param {*} source Source array
 * @param {*} options options object provided by deepmerge's merge function
 * @returns
 */
exports.arrayCombineMerge = (target, source, options) => {
    const destination = target.slice();
    source.forEach((item, index) => {
        if (typeof destination[index] === 'undefined') {
            destination[index] = options.cloneUnlessOtherwiseSpecified(item, options);
        }
        else if (options.isMergeableObject(item)) {
            destination[index] = deepmerge_1.default(target[index], item, options);
        }
        else if (target.indexOf(item) === -1) {
            destination.push(item);
        }
    });
    return destination;
};
//# sourceMappingURL=utils.js.map